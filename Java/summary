자바 프로그램 실행 원리
  Program
  Java Virtual Machine
  Operating System
  hardware
-------------------------
운영체제 위에 Java Virtual Machine을 실행 시켜서 프로그램을 실행시키는 구조로
운영체제와 상관없이 프로그램을 실행 시킬 수 있다. * 단, 운영체제에 따라 Java Virtual Machine을 다르게 설치해야함

자바로 프로그램을 만들기 위해서는 그에 따른 기본 도구가 필요한데, 이 도구를 가리켜 JDK(Java Developement Kit)이라 한다.
JDK를 설치한 후에 설치된 경로(C:\Program Files\Java)에 jdk로 시작하는 디렉토리 안에 bin 디렉토리가 존재하는데 이곳에는 자바의 개발 및 실행에 필요한 여러가지 도구가 존재한다.
그 중 Javac.exe(자바 컴파일러) 와 Java.exe(자바 런처)는 명령프롬프트에서 어느 경로에서든 실행 가능해야 한다. 그래서 이 두 파일이 저장된 경로를 환경 변수 Path에 추가시켜야 한다.
  * 환경 변수 Path는 윈도우 OS가 명령 프롬프트에서 입력된 실행파일을 찾는 경로의 정보가 되어, 
    명령프롬프트에서 디렉토리 경로에 상관없이 실행되기를 원하는 실행파일이 있다면 그 경로를 환경변수 Path에 등록해야한다.

javac.exe(자바 컴파일러)는 test.java(소스파일)를 Java Virtual Machine이 이해할 수 있는 자바 바이트코드로 변환시켜 test.class 파일을 생성하고
java.exe(자바 런처)는 Java Virtual Machine을 구동하고 그 위에 자바 프로그램이 실행되도록 돕는 프로그램이다.

Vscode에서 Java 사용방법
https://blog.naver.com/twonkang00/222487985798

통합개발환경 없이 컴파일 및 실행 방법
메모장에 간단한 코드 작성 후 test.java 파일 저장
명령프롬프트로 해당 파일이 저장된 경로로 들어가서 javac test.java 입력 -> 자바 컴파일
test.class 파일이 생성된 것을 확인 후 java test 입력 -> 실행

println 출력
System.out.println("1"+2);       -> 출력결과 12
System.out.println("1" + "2");   -> 출력결과 12  // println은 출력할 대상을 + 기호로 묶을 수 있음
System.out.println(7 + 5);       -> 출력결과 12  // println은 수를 대상으로 하는 +는 연산으로 이어져 출력됨
System.out.println("1"+2+5);     -> 출력결과 125  
System.out.println("1"+(2+5));   -> 출력결과 17

주석처리 : /*~*/, //

변수(Variable) : 데이터의 저장과 참조를 위해 "할당된 메모리 공간"에 붙인 이름
 ex) int num; -> 변수 선언 : 정수를 저장할 메모리 공간을 할당하고 이름을 num이라고 붙여서, 메모리 공간에 접근할 때에는 num이라는 이름을 사용하겠습니다.

자료형(Data Type) : 변수에 저장할 데이터의 유형

기본 자료형
 자료형  데이터  크 기  표현 가능 범위
boolean 참,거짓 1byte  true, false
  char   문자   2byte  유니코드 문자
  byte   정수   1byte  -128 ~ 127
 short   정수   2byte  -32768 ~ 32767
  int    정수   4byte  -2147483648 ~ 2147483647
  long   정수   8byte  -9223372036854775808 ~ 9223372036854775807
 float   실수   4byte  +-(1.40*10^(-45) ~ 3.40*10^38)
 double  실수   8byte  +-(4.94*10^(-324) ~ 1.79*10^308)
  * 실수 표현에는 오차가 존재함.

변수의 이름 제약사항
1.자바에서는 대소문자를 구분 ex) num1 != Num1
2.숫자로 시작할 수 없음
3.$과 _ 이외의 다른 특수문자는 사용할 수 없음
4.키워드는 사용할 수 없음 ex) int int; (x)

정수의 표현 방식
MSB를 사용하여 양수와 음수를 표현
 * MSB(Most Significant Bit) : 부호를 결정짓는 가장 왼쪽에 위치한 비트(0 : 양수, 1 : 음수)
  음의 정수의 경우 2의보수를 취한 결과로 표현 ex) 0000 0001 = 1 -> 1의보수 : 1111 1110 -> 2의 보수 : 1111 1111 = -1

실수의 표현 방식
정밀도를 낮추는 대신 표현할 수 있는 값의 범위를 넓힘 -> 오차가 존재
 IEEE754 표준 : +-(1.m)*2^(e-127)

정수 자료형 (byte, short, int, long)
자바는 정수형 연산을 4byte int형으로만 진행. 즉, byte형 변수나 short형 변수에 저장된 값을 대상으로 연상을 진행할경우 먼저 int형 값으로 변경시킴
그래서 연산을 동반하는 상황에서는 변수를 byte, short로 선언해도 생각만큼 메모리가 절약되지 않고 오히려 데이터 변환 과정만 추가될 뿐이므로, int로 선언하는 것을 추천
, long형의 경우 int형으로 변환시킬 경우 데이터의 손실이 발생하므로 long형 데이터를 피연산자로 하는 연산 시에는 int형으로 변환이 발생하지 않음

실수 자료형 (float, double)
실수 자료형 float 과 double 사이에서 자료형을 선택하는 기준은 정밀도에 있음.
float는 소수점 이하 6자리까지는 오차가 발생하지 않고 double은 소수점 이하 15자리까지 오차가 발생하지 않음.
하지만 데이터 둘 이상을 더하다보면, 소수점 이하 셋째자리에서 오차가 발견될 수도 있음. 그러므로 실수의 계산은 기본적으로 오차가 존재한다고 가정해야 함.

문자 자료형 (char)
하드웨어가 수밖에 인식을 못하므로 문자 하나하나에 숫자를 부여하는 수밖에 없다. 이러한 문자의 표현에 대한 약속을 가리켜 문자 셋(Character set)이라 한다.
유니코드(Unicode) : 모든 나라의 문자를 수용하여 전 세계적으로 사용할 수 있는 문자 셋을 설계한 것으로 문자 하나를 2바이트로 표현하는 문자 체계이다.
 ex) char ch1 = '헐';    출력한 결과 = 헐 -> 유니코드 값으로 치환되어 저장. 문자는 ''(작은 따옴표)로 묶어서 표현
     char ch1 = 54739;   출력한 결과 = 헐 -> 10진수로 유니코드 값 저장
     char ch1 = 0xD5D0;  출력한 결과 = 헐 -> 16진수로 유니코드 값 저장

논리 자료형 (boolean)
참과 거짓의 표현을 목적으로 존재하며 참은 true, 거짓은 false를 변수에 저장할수 있다.
ex) boolean isBlue = true;
    boolean isBlue = false;

상수(Constants) : 값이 변하지 않는 수 or 한번 그 값이 정해지면 이후로는 변경이 불가능한 변수
 변수 앞에 final이라는 선언을 추가하면 그 변수는 상수가 된다. 값을 딱 1번만 할당할 수 있으며, 한번 할당된 값은 변경이 불가능하다.
  ex) final int MAX_SIZE = 100;
      final int CONST_CHAR;                 // 상수 이름은 모두 대문자로 지으며, 이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.
      CONST_CHAR = '상';

리터럴(Literals) : 대입 연산자의 오른편에 위치한 숫자를 가리켜 리터럴 or 리터럴 상수 or 그냥 상수라고도 함
 ex) int num = 157;  // 157은 리터럴 상수

자바는 변수의 자료형에 상관없이 정수는 int형으로 표현하기로 약속되어 있음.
 ex) long num = 3147483647;   // 오류 발생 error: integer number too large: 3147483647 -> int형 정수에 담기에는 너무 크다

정수형 상수의 표현 방법
 2진수 : int num = 0B111;  // 2진수 표현 앞에 0b or 0B 삽입
 8진수 : int num = 011;    // 숫자 앞에 0 삽입
 10진수 : int num = 11;
 16진수 : int num = 0x11;  // 숫자 앞에 0x or 0X 삽입

byte, short형은 따로 정수의 표현 방법을 제공하지 않으므로 그냥 사용
 ex) byte num1 =5;
     short num1 = 5;

long형은 숫자의 끝에 l or L을 삽입
 ex) long num1 = 3147483647l;
     long num1 = 3147483647L;

 * 단위가 큰 수의 표현 및 인식에 도움을 주기 위해 중간에 언더바를 넣는 것도 허용됨
    ex) int num = 100_000;
        int num = 12_34_56_78_90;

실수형 상수는 double형으로 인식
 ex) double pi = 3.1415;

float형은 숫자 끝에 f or F를 삽입
double형도 명시적으로 표현하기위해 d or D를 삽입 가능
ex) double pi = 3.1415d;
    float pi = 3.1415f;

실수형 상수의 표현방법
 3.4e3    // 3.4*10^3
 3.4e3f   // 3.4*10^3
 .5       // 0.5 앞에 붙은 0 생략 가능
 7.       // 7.0 뒤에 붙은 0 생략 가능
 .5f      // 0.5f
 7.f      // 7.0f

부울형 상수 : true, false
문자형 상수 : char ch = '한';

이스케이프 시퀀스(escape sequence) : 유니코드 문자들 중 키보드로 입력하기 어려운 문자의 표현을 위한 것
 '\b' : 백스페이스 문자
   ex) System.out.println("AB" + '\b' + 'C');  // 출력결과 : AC
 '\t' : 탭 문자
   ex) System.out.println("AB" + '\t' + 'C');  // 출력결과 : AB  C
 '\\' : 백슬래시 문자
   ex) System.out.println("AB" + '\\' + 'C');  // 출력결과 : AB\C
 '\'' : 작은따옴표 문자
   ex) System.out.println("AB" + '\'' + 'C');  // 출력결과 : AB'C
 '\"' : 큰따옴표 문자
   ex) System.out.println("AB" + '\"' + 'C');  // 출력결과 : AB"C
 '\n' : 개 행 문자
   ex) System.out.println("AB" + '\n' + 'C');  // 출력결과 : AB
   ;                                           //           C
 '\r' : 캐리지 리턴(carriage return) 문자
   ex) System.out.println("AB" + '\r' + 'C');  // 출력결과 : CB -> '\r'은 커서를 왼쪽 끝으로 이동시키기 때문에 A의 위치에서 C를 출력시켜 A가 지워짐
 '\u' : 특수문자의 경우 \u로 이스케이프 시퀀스를 구성하여 원하는 문자 출력 가능
   ex) '\u20AC'

 * 큰따옴표("")와 작은따옴표('')의 차이점 : C, C++, JAVA에서는 문자열과 문자의 차이이고 자바스크립트나 파이썬같은 언어는 차이 없음.
  큰따옴표의 경우 문자열로 인식하여 두문자가 합쳐져서 결과가 표시되며, 작은 따옴표의 경우는 + 연산자와 사용하면 integer형으로 형변환이 되어 출력됨
  ex) System.out.println("H" + 'a');   // 출력결과 : Ha
      System.out.println('H' + 'a');   // 출력결과 : 169
      System.out.println('H' + 0);     // 출력결과 : 72
      System.out.println('a' + 0);     // 출력결과 : 97

형 변환 : 자료형이 다른 두 값을 대상으로 연산을 진행하지 못하므로 두 변수의 자료형을 하나로 일치시키는 과정
 자동 형 변환(Implicit Conversion) : 따로 명시하지 않아도 필요한 상황에서 자동으로 일어나는 형 변환
  규칙 1. 자료형의 크기가 큰 방향으로 형 변환이 일어난다.
  규칙 2. 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.
  byte -> short -> int -> long -> float -> double
           char -> int -> long -> float -> double
   ex) int num1 = 50;
       long num2 = 3147483647L;
       System.out.println(num1 + num2); // num1에 저장된 값을 long형으로 변환하여 메모리에 임시 저장 후, 변환된 값과 num2에 저장된 값을 대상으로 덧셈을 진행
   ex) double num1 = 30; int형 정수 30을 double형으로 자동 형 변환하여 저장
 
 명시적 형 변환(Explicit Conversion) : 자동 형 변환이 진행되지 않는 상황에서 필요한 경우에 사용하는 형 변환으로 (자료형)을 붙여서 사용
  ex) double pi = 3.1415;
      int wholeNumber = (int)pi;
      * 큰 자료형에서 작은 크기의 자료형으로 형 변환을 진행하는 경우에는 상위 바이트가 잘려 나간다. 상위 바이트에 유효한 데이터가 존재하는 경우에는 알 수 없는 값으로 변환되므로 주의 해야 함.

이항 연산자(Binary operator) : 피연산자가 둘인 연산자 ex) = , +
연산 순서를 결정짓는 첫 번째 요소는 우선순위이고 두 번째 요소는 결합 방향이다.

대입연산자 = (결합 방향 <-)
산술연산자 +, -, *, /, % (결합 방향 : ->)      // *, %, /는 +, -보다 우선순위가 높음
 * 정수의 경우 /(나눗셈)은 몫만 출력되며, %가 나머지를 출력.
 
 * 특정 연산을 소괄호로 묶어주면 이 부분이 별도로 구분이 되어 연산자의 우선순위에 상관없이 해당 부분의 연산이 먼저 진행되므로,
   소괄호로 연산의 순서 및 과정을 구분 지어 주면 코드가 한결 이해하기 쉬우므로 참고할 것.

복합(Compound) 대입 연산자 : 대입 연산자가 다른 연산자와 묶여서 정의된 형태의 연산자
  a += b  ->  a = a + b
  a -= b  ->  a = a - b
  a *= b  ->  a = a * b
  a /= b  ->  a = a / b
  a %= b  ->  a = a % b

   *** 복합 대입 연산자를 사용하면 형변환이 필요하지 않는다.
    ex) short num =10;
        num = (short)(num + 77L);    // 명시적 형 변환을 하지 않으면 컴파일 오류 발생
        num += 77L;                  // 형 변환을 따로 하지 않아도 알아서 해줌 -> 명시적 형 변환을 줄일 수 있다는 장점이 있다.

관계 연산자(<, >, <=, >=, ==, !=) : 두 개의 피연산자 사이에서 크기 및 동등 관계를 따져주는 이항 연산자로, 연산 결과에 따라 true or false를 반환
  ex) System.out. println(" 3 >= 2 : " + (3 >= 2));       //출력 결과 : 3 >= 2 : true
      System.out. println(" 3 <= 2 : " + (3 >= 2));       //출력 결과 : 3 <= 2 : false

논리 연산자(&&, ||, !) : true or false를 반환하는 연산자로, 피연산자는 true or false이어야 함.
  && : 피연산자가 둘 다 참이여야 참 반환, 나머지는 거짓 반환
  || : 피연산자가 둘 중 하나만 참이여도 참 반환, 둘 다 거짓일때 거짓 반환
   ! : 피연산자의 반대값 반환, 피연산자가 참이면 거짓, 거짓이면 참을 반환

  *** Short-Circuit Evaluation(Lazy Evaluation) : 연산의 효율을 높이기 위해서 불필요한 연산을 생략하는 행위
    && : 좌측의 피연산자가 거짓일 경우, 우측의 피연산자는 연산을 하지 않고 거짓 반환
     ex) int num1 = 0;
         int num2 = 0;
         result = ((num1 += 10) < 0) && ((num2 += 10) > 0);   // (num1 += 10) < 0 이 거짓이므로 (num2 += 10) > 0는 연산하지 않고 result에 false값 저장이 되어 num1 = 10; num2 = 0; 상태
    || : 좌측의 피연산자가 참일 경우, 우측의 피연산자는 연산을 하지 않고 참 반환
     ex) int num1 = 0;
         int num2 = 0;
         result = ((num1 += 10) > 0) || ((num2 += 10) > 0);   // (num1 += 10) > 0 이 참이므로 (num2 += 10) > 0는 연산하지 않고 result에 true값 저장이 되어 num1 = 10; num2 = 0; 상태
    그래서 문장을 구성할 때 하나의 문장에 너무 많은 연산을 포함하지 않는 것이 좋음.

부호 연산자(+, -) : 덧셈과 뺄셈에서 이항연산자로 사용되지만, 단항 연산자로도 의미를 갖음. 
 ex) short num2 =7;
     short num3 = (short)(+num2);   // 결과로만 보았을 때는 의미가 없는 연산이지만 실제 연산의 과정을 거치므로 형 변환을 하지 않으면 오류 발생

증가 및 감소 연산자 : 증가 및 감소된 값을 단순히 반환하는 것이 아니라 실제 변수에 저장된 값을 변화시키는 연산자.
  Prefix ++, Prefix -- : 피연산자의 앞부분(좌측)에 붙는 연산자로, 피연산자에 저장된 값을 1 증가시키거나, 1 감소시킴
   ex) int num1 =5;
      System.out.println((num1++) + " " + (num1++));     // 출력 결과 : 5 6
      System.out.println(num1);                          // 출력 결과 : 7
  Postfix ++, Postfix -- : 피연산자의 뒷부분(우측)에 붙는 연산자로, 피연산자에 저장된 값을 1 증가시키거나, 1 감소시키지만 다음 문장으로 넘어가야 반영됨.
   ex) int num2 =5;
      System.out.println((++num2) + " " + (++num2));     // 출력 결과 : 6 7
      System.out.println(num2);                          // 출력 결과 : 7

비트 연산자(&, |, ^, ~) : 비트를 대상으로 연산을 진행하는 연산자이며 피연산자는 반드시 정수이어야 한다.
  & : 비트 단위로 AND 연산(두 비트가 모두 1일 때 1을 반환)
  | : 비트 단위로 OR 연산(두 비트 중 하나라도 1일 때 1을 반환)
  ^ : 비트 단위로 XOR 연산(두 비트가 서로 다를 때 1을 반환)
  ~ : 비트 단위로 NOT 연산(비트의 반대 값을 반환, 0일 때 1을, 1일 때 0을 반환)

비트 쉬프트(Shift) 연산자(<<, >>, >>>) : 비트 열을 왼쪽 또는 오른쪽으로 이동시킨 결과를 반환하는 연산자
  << : 피연산자의 비트 열을 왼쪽으로 이동, 이동에 따른 빈공간은 0으로 채움
  >> : 피연산자의 비트 열을 오른쪽으로 이동, 이동에 따른 빈공간은 음수의 경우 1로, 양수의 경우 0으로 채움
  >>> : 피연산자의 비트 열을 오른쪽으로 이동, 이동에 따른 빈공간은 0으로 채움
   * 비트열을 왼쪽으로 한 칸 이동하고 빈공간을 0으로 채울 때마다 그 값은 두배씩 증가한다.